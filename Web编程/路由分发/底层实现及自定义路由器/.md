### Go 语言路由映射和请求分发的底层实现及自定义路由器

引子

从这一篇教程起，我们将从自定义路由开始探索 Go Web 编程之旅。

开始之前，我们还是回顾下创建第一个 Web 应用中的示例代码：

http.HandleFunc("/",sayHelloWorld)  // HandleFunc 注册一个处理器函数handler和和对应的模式pattern
err:=http.ListenAndServe(":9091",nil) //  这里 http.ListenAndServe 方法第二个参数传入的是 nil，表示底层会使用默认的 DefaultServeMux 实现将上述 HandleFunc 方法传入的处理函数转化为类似 Laravel 框架中基于闭包方式定义的路由


### 自定义路由处理器

如果你搞清楚了上面的默认实现，编写自定义的路由处理器就会非常简单，我们只需要定义一个实现了 Handler 接口的类，
然后将其实例传递给 http.ListenAndServe 方法即可：

+ 案例
 * 1.go


这个实现很简单，而且我们并没有在应用启动期间初始化路由映射规则，而是在应用启动之后根据请求参数动态判断来做分发的，这样做会影响性能，而且非常不灵活，
我们可以通过定义多个处理器的方式来解决这个问题

+ 案例
 * 2.go

只是，我们又回到了老路子上，这里没有显式传入 handler，所以底层依然使用的是 DefaultServeMux 那套路由映射与请求分发机制，
要实现完全自定义的、功能更加强大的处理器，只能通过自定义 ServeMux 来实现了，不过在这个领域，已经有非常好的第三方轮子可以直接拿来用了，
比如 gorilla/mux 就是其中之一，后续教程我们都将使用它作为路由器，下篇教程我们将简单介绍它的基本使用。